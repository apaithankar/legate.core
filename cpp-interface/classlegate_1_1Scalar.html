<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Legate: legate::Scalar Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Legate<span id="projectnumber">&#160;22.12.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>legate</b></li><li class="navelem"><a class="el" href="classlegate_1_1Scalar.html">Scalar</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classlegate_1_1Scalar-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">legate::Scalar Class Reference<div class="ingroups"><a class="el" href="group__data.html">Data abstractions and allocators</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A type-erased container for scalars and tuples of scalars.  
 <a href="classlegate_1_1Scalar.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="scalar_8h_source.html">core/data/scalar.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3bcd1a3a181f33eae5f5458f4917528d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Scalar.html#a3bcd1a3a181f33eae5f5458f4917528d">Scalar</a> (bool tuple, LegateTypeCode code, const void *data)</td></tr>
<tr class="memdesc:a3bcd1a3a181f33eae5f5458f4917528d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shared <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code> with an existing allocation. The caller is responsible for passing in a sufficiently big allocation.  <a href="classlegate_1_1Scalar.html#a3bcd1a3a181f33eae5f5458f4917528d">More...</a><br /></td></tr>
<tr class="separator:a3bcd1a3a181f33eae5f5458f4917528d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab08bde944f6de6f836591014da8ac57"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aab08bde944f6de6f836591014da8ac57"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlegate_1_1Scalar.html#aab08bde944f6de6f836591014da8ac57">Scalar</a> (T <a class="el" href="classlegate_1_1Scalar.html#af07a5fc262af39d16f22094ac55addbe">value</a>)</td></tr>
<tr class="memdesc:aab08bde944f6de6f836591014da8ac57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an owned scalar from a scalar value.  <a href="classlegate_1_1Scalar.html#aab08bde944f6de6f836591014da8ac57">More...</a><br /></td></tr>
<tr class="separator:aab08bde944f6de6f836591014da8ac57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f763d06669ea2cfd62d717ee5bf23a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2f763d06669ea2cfd62d717ee5bf23a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlegate_1_1Scalar.html#aa2f763d06669ea2cfd62d717ee5bf23a">Scalar</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classlegate_1_1Scalar.html#a2b2d2da382e63b2488a3ed4524bef3fc">values</a>)</td></tr>
<tr class="memdesc:aa2f763d06669ea2cfd62d717ee5bf23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an owned scalar from a tuple of scalars. The values in the input vector will be copied.  <a href="classlegate_1_1Scalar.html#aa2f763d06669ea2cfd62d717ee5bf23a">More...</a><br /></td></tr>
<tr class="separator:aa2f763d06669ea2cfd62d717ee5bf23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89e6cef8ed90036c38bfbc279c054bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Scalar.html#ac89e6cef8ed90036c38bfbc279c054bc">is_tuple</a> () const</td></tr>
<tr class="memdesc:ac89e6cef8ed90036c38bfbc279c054bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if the <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code> object represents a tuple.  <a href="classlegate_1_1Scalar.html#ac89e6cef8ed90036c38bfbc279c054bc">More...</a><br /></td></tr>
<tr class="separator:ac89e6cef8ed90036c38bfbc279c054bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22af4176ea48f6ac0e8415aea8876942"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Scalar.html#a22af4176ea48f6ac0e8415aea8876942">size</a> () const</td></tr>
<tr class="memdesc:a22af4176ea48f6ac0e8415aea8876942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of allocation for the <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code>.  <a href="classlegate_1_1Scalar.html#a22af4176ea48f6ac0e8415aea8876942">More...</a><br /></td></tr>
<tr class="separator:a22af4176ea48f6ac0e8415aea8876942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07a5fc262af39d16f22094ac55addbe"><td class="memTemplParams" colspan="2">template&lt;typename VAL &gt; </td></tr>
<tr class="memitem:af07a5fc262af39d16f22094ac55addbe"><td class="memTemplItemLeft" align="right" valign="top">VAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlegate_1_1Scalar.html#af07a5fc262af39d16f22094ac55addbe">value</a> () const</td></tr>
<tr class="memdesc:af07a5fc262af39d16f22094ac55addbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value stored in the <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code>. The call does no type checking; i.e., passing a wrong type parameter will not be caught by the call.  <a href="classlegate_1_1Scalar.html#af07a5fc262af39d16f22094ac55addbe">More...</a><br /></td></tr>
<tr class="separator:af07a5fc262af39d16f22094ac55addbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2d2da382e63b2488a3ed4524bef3fc"><td class="memTemplParams" colspan="2">template&lt;typename VAL &gt; </td></tr>
<tr class="memitem:a2b2d2da382e63b2488a3ed4524bef3fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlegate_1_1Span.html">Span</a>&lt; const VAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlegate_1_1Scalar.html#a2b2d2da382e63b2488a3ed4524bef3fc">values</a> () const</td></tr>
<tr class="memdesc:a2b2d2da382e63b2488a3ed4524bef3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns values stored in the <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code>. If the <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code> contains a scalar, a unit span will be returned.  <a href="classlegate_1_1Scalar.html#a2b2d2da382e63b2488a3ed4524bef3fc">More...</a><br /></td></tr>
<tr class="separator:a2b2d2da382e63b2488a3ed4524bef3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2356320d615f945b363586de4f79de6e"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Scalar.html#a2356320d615f945b363586de4f79de6e">ptr</a> () const</td></tr>
<tr class="memdesc:a2356320d615f945b363586de4f79de6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw pointer to the backing allocation.  <a href="classlegate_1_1Scalar.html#a2356320d615f945b363586de4f79de6e">More...</a><br /></td></tr>
<tr class="separator:a2356320d615f945b363586de4f79de6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A type-erased container for scalars and tuples of scalars. </p>
<p >A <a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a> can be owned or shared, depending on whether it owns the backing allocation: If a <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code> is shared, it does not own the allocation and any of its copies are also shared. If a <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code> is owned, it owns the backing allocation and releases it upon destruction. Any copy of an owned <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code> is owned as well.</p>
<p >A <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code> that stores a tuple of scalars has an allocation big enough to contain both the number of elements and the elements themselves. The number of elements should be stored in the first four bytes of the allocation. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3bcd1a3a181f33eae5f5458f4917528d" name="a3bcd1a3a181f33eae5f5458f4917528d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bcd1a3a181f33eae5f5458f4917528d">&#9670;&#160;</a></span>Scalar() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">legate::Scalar::Scalar </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LegateTypeCode&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a shared <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code> with an existing allocation. The caller is responsible for passing in a sufficiently big allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>If true, the allocation contains a tuple of scalars. </td></tr>
    <tr><td class="paramname">code</td><td>Type code of the scalar(s) </td></tr>
    <tr><td class="paramname">data</td><td>Allocation containing the data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab08bde944f6de6f836591014da8ac57" name="aab08bde944f6de6f836591014da8ac57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab08bde944f6de6f836591014da8ac57">&#9670;&#160;</a></span>Scalar() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">legate::Scalar::Scalar </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an owned scalar from a scalar value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type to wrap</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A scalar value to create a <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code> with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2f763d06669ea2cfd62d717ee5bf23a" name="aa2f763d06669ea2cfd62d717ee5bf23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f763d06669ea2cfd62d717ee5bf23a">&#9670;&#160;</a></span>Scalar() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">legate::Scalar::Scalar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an owned scalar from a tuple of scalars. The values in the input vector will be copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>A vector that contains elements of a tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac89e6cef8ed90036c38bfbc279c054bc" name="ac89e6cef8ed90036c38bfbc279c054bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89e6cef8ed90036c38bfbc279c054bc">&#9670;&#160;</a></span>is_tuple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool legate::Scalar::is_tuple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if the <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code> object represents a tuple. </p>
<dl class="section return"><dt>Returns</dt><dd>true The <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code> is a tuple </dd>
<dd>
false The <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code> is a scalar </dd></dl>

</div>
</div>
<a id="a2356320d615f945b363586de4f79de6e" name="a2356320d615f945b363586de4f79de6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2356320d615f945b363586de4f79de6e">&#9670;&#160;</a></span>ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void * legate::Scalar::ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a raw pointer to the backing allocation. </p>
<dl class="section return"><dt>Returns</dt><dd>A raw pointer to the <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code>'s data </dd></dl>

</div>
</div>
<a id="a22af4176ea48f6ac0e8415aea8876942" name="a22af4176ea48f6ac0e8415aea8876942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22af4176ea48f6ac0e8415aea8876942">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t legate::Scalar::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of allocation for the <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of allocation </dd></dl>

</div>
</div>
<a id="af07a5fc262af39d16f22094ac55addbe" name="af07a5fc262af39d16f22094ac55addbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07a5fc262af39d16f22094ac55addbe">&#9670;&#160;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VAL legate::Scalar::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value stored in the <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code>. The call does no type checking; i.e., passing a wrong type parameter will not be caught by the call. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VAL</td><td>Type of the value to unwrap</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value stored in the <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code> </dd></dl>

</div>
</div>
<a id="a2b2d2da382e63b2488a3ed4524bef3fc" name="a2b2d2da382e63b2488a3ed4524bef3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2d2da382e63b2488a3ed4524bef3fc">&#9670;&#160;</a></span>values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlegate_1_1Span.html">Span</a>&lt; const VAL &gt; legate::Scalar::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns values stored in the <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code>. If the <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code> contains a scalar, a unit span will be returned. </p>
<dl class="section return"><dt>Returns</dt><dd>Values stored in the <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars and tuples of scalars.">Scalar</a></code> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="scalar_8h_source.html">scalar.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
