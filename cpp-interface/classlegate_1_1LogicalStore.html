<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Legate: legate::LogicalStore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Legate<span id="projectnumber">&#160;24.01.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>legate</b></li><li class="navelem"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classlegate_1_1LogicalStore-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">legate::LogicalStore Class Reference<div class="ingroups"><a class="el" href="group__data.html">Data abstractions and allocators</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A multi-dimensional data container.  
 <a href="classlegate_1_1LogicalStore.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="logical__store_8h_source.html">core/data/logical_store.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a66d3bd0de29e247721460479160562fd" id="r_a66d3bd0de29e247721460479160562fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1LogicalStore.html#a66d3bd0de29e247721460479160562fd">dim</a> () <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a></td></tr>
<tr class="memdesc:a66d3bd0de29e247721460479160562fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of dimensions of the store.  <br /></td></tr>
<tr class="separator:a66d3bd0de29e247721460479160562fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36410c0eabe00b906769df56ee021f94" id="r_a36410c0eabe00b906769df56ee021f94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1LogicalStore.html#a36410c0eabe00b906769df56ee021f94">has_scalar_storage</a> () <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a></td></tr>
<tr class="memdesc:a36410c0eabe00b906769df56ee021f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the store's storage is optimized for scalars.  <br /></td></tr>
<tr class="separator:a36410c0eabe00b906769df56ee021f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd476e18b38c5ac51ecbbd4886fb9315" id="r_acd476e18b38c5ac51ecbbd4886fb9315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1LogicalStore.html#acd476e18b38c5ac51ecbbd4886fb9315">overlaps</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">other</a>) <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a></td></tr>
<tr class="memdesc:acd476e18b38c5ac51ecbbd4886fb9315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this store overlaps with a given store.  <br /></td></tr>
<tr class="separator:acd476e18b38c5ac51ecbbd4886fb9315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc34f63b1a83aa05270e79d59d6fbd5" id="r_a4dc34f63b1a83aa05270e79d59d6fbd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1LogicalStore.html#a4dc34f63b1a83aa05270e79d59d6fbd5">type</a> () <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a></td></tr>
<tr class="memdesc:a4dc34f63b1a83aa05270e79d59d6fbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element type of the store.  <br /></td></tr>
<tr class="separator:a4dc34f63b1a83aa05270e79d59d6fbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09e36664ff6cb6815bb26afb92f123b" id="r_ac09e36664ff6cb6815bb26afb92f123b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1LogicalStore.html#ac09e36664ff6cb6815bb26afb92f123b">extents</a> () <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a></td></tr>
<tr class="memdesc:ac09e36664ff6cb6815bb26afb92f123b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the shape of the store.  <br /></td></tr>
<tr class="separator:ac09e36664ff6cb6815bb26afb92f123b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c29db25efa34cbaa864b53f5678f28" id="r_a11c29db25efa34cbaa864b53f5678f28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1LogicalStore.html#a11c29db25efa34cbaa864b53f5678f28">volume</a> () <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a></td></tr>
<tr class="memdesc:a11c29db25efa34cbaa864b53f5678f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the store.  <br /></td></tr>
<tr class="separator:a11c29db25efa34cbaa864b53f5678f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa631a7c6fc21a2354c8742b2556207a7" id="r_aa631a7c6fc21a2354c8742b2556207a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1LogicalStore.html#aa631a7c6fc21a2354c8742b2556207a7">unbound</a> () <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a></td></tr>
<tr class="memdesc:aa631a7c6fc21a2354c8742b2556207a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the store is unbound.  <br /></td></tr>
<tr class="separator:aa631a7c6fc21a2354c8742b2556207a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3624c47c0b0e8167d646a3ff3ff9cf84" id="r_a3624c47c0b0e8167d646a3ff3ff9cf84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1LogicalStore.html#a3624c47c0b0e8167d646a3ff3ff9cf84">transformed</a> () <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a></td></tr>
<tr class="memdesc:a3624c47c0b0e8167d646a3ff3ff9cf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the store is transformed.  <br /></td></tr>
<tr class="separator:a3624c47c0b0e8167d646a3ff3ff9cf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd14524f3cdb3e83cf29a1492f4f559" id="r_a4cd14524f3cdb3e83cf29a1492f4f559"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1LogicalStore.html#a4cd14524f3cdb3e83cf29a1492f4f559">promote</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">extra_dim</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">size_t</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">dim_size</a>) <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a></td></tr>
<tr class="memdesc:a4cd14524f3cdb3e83cf29a1492f4f559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an extra dimension to the store.  <br /></td></tr>
<tr class="separator:a4cd14524f3cdb3e83cf29a1492f4f559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef189837b27fe30356ae8b94bd18756" id="r_a7ef189837b27fe30356ae8b94bd18756"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1LogicalStore.html#a7ef189837b27fe30356ae8b94bd18756">project</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a> <a class="el" href="classlegate_1_1LogicalStore.html#a66d3bd0de29e247721460479160562fd">dim</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int64_t</a> index) <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a></td></tr>
<tr class="memdesc:a7ef189837b27fe30356ae8b94bd18756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects out a dimension of the store.  <br /></td></tr>
<tr class="separator:a7ef189837b27fe30356ae8b94bd18756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc89d4f41504681a0595c5e90376741" id="r_aecc89d4f41504681a0595c5e90376741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1LogicalStore.html#aecc89d4f41504681a0595c5e90376741">slice</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a> <a class="el" href="classlegate_1_1LogicalStore.html#a66d3bd0de29e247721460479160562fd">dim</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Slice</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">sl</a>) <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a></td></tr>
<tr class="memdesc:aecc89d4f41504681a0595c5e90376741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slices a contiguous sub-section of the store.  <br /></td></tr>
<tr class="separator:aecc89d4f41504681a0595c5e90376741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa598551a463bbe85c1dff446579faecc" id="r_aa598551a463bbe85c1dff446579faecc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1LogicalStore.html#aa598551a463bbe85c1dff446579faecc">transpose</a> (std::vector&lt; <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a> &gt; &amp;&amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">axes</a>) <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a></td></tr>
<tr class="memdesc:aa598551a463bbe85c1dff446579faecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders dimensions of the store.  <br /></td></tr>
<tr class="separator:aa598551a463bbe85c1dff446579faecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5fce69d2070da76fe377446296a1d9" id="r_afa5fce69d2070da76fe377446296a1d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1LogicalStore.html#afa5fce69d2070da76fe377446296a1d9">delinearize</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a> <a class="el" href="classlegate_1_1LogicalStore.html#a66d3bd0de29e247721460479160562fd">dim</a>, std::vector&lt; <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">uint64_t</a> &gt; <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">sizes</a>) <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a></td></tr>
<tr class="memdesc:afa5fce69d2070da76fe377446296a1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delinearizes a dimension into multiple dimensions.  <br /></td></tr>
<tr class="separator:afa5fce69d2070da76fe377446296a1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb057c7b941dbf4e6e9a0fdcb062952b" id="r_abb057c7b941dbf4e6e9a0fdcb062952b"><td class="memItemLeft" align="right" valign="top">LogicalStorePartition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1LogicalStore.html#abb057c7b941dbf4e6e9a0fdcb062952b">partition_by_tiling</a> (std::vector&lt; <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">size_t</a> &gt; <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">tile_shape</a>) <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a></td></tr>
<tr class="memdesc:abb057c7b941dbf4e6e9a0fdcb062952b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a tiled partition of the store.  <br /></td></tr>
<tr class="separator:abb057c7b941dbf4e6e9a0fdcb062952b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf035385d22273c70c0ca1f9ff0d8e05" id="r_acf035385d22273c70c0ca1f9ff0d8e05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1PhysicalStore.html">PhysicalStore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1LogicalStore.html#acf035385d22273c70c0ca1f9ff0d8e05">get_physical_store</a> () <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a></td></tr>
<tr class="memdesc:acf035385d22273c70c0ca1f9ff0d8e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a physical store for this logical store.  <br /></td></tr>
<tr class="separator:acf035385d22273c70c0ca1f9ff0d8e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bfbb96c49998b45890fe725ff0b102" id="r_a91bfbb96c49998b45890fe725ff0b102"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1LogicalStore.html#a91bfbb96c49998b45890fe725ff0b102">detach</a> ()</td></tr>
<tr class="memdesc:a91bfbb96c49998b45890fe725ff0b102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach a store from its attached memory.  <br /></td></tr>
<tr class="separator:a91bfbb96c49998b45890fe725ff0b102"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A multi-dimensional data container. </p>
<p><code><a class="el" href="classlegate_1_1LogicalStore.html" title="A multi-dimensional data container.">LogicalStore</a></code> is a multi-dimensional data container for fixed-size elements. Stores are internally partitioned and distributed across the system. By default, Legate clients need not create nor maintain the partitions explicitly, and the Legate runtime is responsible for managing them. Legate clients can control how stores should be partitioned for a given task by attaching partitioning constraints to the task (see the constraint module for partitioning constraint APIs).</p>
<p>Each logical store object is a logical handle to the data and is not immediately associated with a physical allocation. To access the data, a client must <code>map</code> the store to a physical store (<code><a class="el" href="classlegate_1_1PhysicalStore.html" title="A multi-dimensional data container storing task data.">PhysicalStore</a></code>). A client can map a store by passing it to a task, in which case the task body can see the allocation, or calling <code>get_physical_store</code>, which gives the client a handle to the physical allocation (see <code><a class="el" href="classlegate_1_1PhysicalStore.html" title="A multi-dimensional data container storing task data.">PhysicalStore</a></code> for details about physical stores).</p>
<p>Normally, a logical store gets a fixed shape upon creation. However, there is a special type of logical stores called <code>unbound</code> stores whose shapes are unknown at creation time. (see <code><a class="el" href="classlegate_1_1Runtime.html" title="Class that implements the Legate runtime.">Runtime</a></code> for the logical store creation API.) The shape of an unbound store is determined by a task that first updates the store; upon the submission of the task, the logical store becomes a normal store. Passing an unbound store as a read-only argument or requesting a physical store of an unbound store are invalid.</p>
<p>One consequence due to the nature of unbound stores is that querying the shape of a previously unbound store can block the client's control flow for an obvious reason; to know the shape of the logical store whose shape was unknown at creation time, the client must wait until the updater task to finish. However, passing a previously unbound store to a downstream operation can be non-blocking, as long as the operation requires no changes in the partitioning and mapping for the logical store. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="afa5fce69d2070da76fe377446296a1d9" name="afa5fce69d2070da76fe377446296a1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5fce69d2070da76fe377446296a1d9">&#9670;&#160;</a></span>delinearize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> legate::LogicalStore::delinearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">uint64_t</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delinearizes a dimension into multiple dimensions. </p>
<p>Each dimension \(i\) of the store, where \(i &gt; \)<code>dim</code>, will be mapped to dimension \(i+N\) of the resulting store, where \(N\) is the length of <code>sizes</code>. A delinearization that does not preserve the size of the store is invalid.</p>
<p>For example, consider a 2D store <code>A</code></p>
<div class="fragment"><div class="line">[[1, 2, 3, 4],</div>
<div class="line"> [5, 6, 7, 8]]</div>
</div><!-- fragment --><p>A delinearizing call <code>A.delinearize(1, {2, 2}))</code> yields:</p>
<div class="fragment"><div class="line">[[[1, 2],</div>
<div class="line">  [3, 4]],</div>
<div class="line"> </div>
<div class="line"> [[5, 6],</div>
<div class="line">  [7, 8]]]</div>
</div><!-- fragment --><p>Unlike other transformations, delinearization is not an affine transformation. Due to this nature, delinearized stores can raise <code><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d" title="Creates a Buffer of specific extents.">legate::NonInvertibleTransformation</a></code> in places where they cannot be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>Dimension to delinearize </td></tr>
    <tr><td class="paramname">sizes</td><td>Extents for the resulting dimensions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new store with the chosen dimension delinearized</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If <code>dim</code> is invalid for the store or <code>sizes</code> does not preserve the extent of the chosen dimenison </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91bfbb96c49998b45890fe725ff0b102" name="a91bfbb96c49998b45890fe725ff0b102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91bfbb96c49998b45890fe725ff0b102">&#9670;&#160;</a></span>detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a> legate::LogicalStore::detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach a store from its attached memory. </p>
<p>This call will wait for all operations that use the store (or any sub-store) to complete.</p>
<p>After this call returns, it is safe to deallocate the attached external allocation. If the allocation was mutable, the contents would be up-to-date upon the return. The contents of the store are invalid after that point. </p>

</div>
</div>
<a id="a66d3bd0de29e247721460479160562fd" name="a66d3bd0de29e247721460479160562fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d3bd0de29e247721460479160562fd">&#9670;&#160;</a></span>dim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a> legate::LogicalStore::dim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of dimensions of the store. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of dimensions </dd></dl>

</div>
</div>
<a id="ac09e36664ff6cb6815bb26afb92f123b" name="ac09e36664ff6cb6815bb26afb92f123b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09e36664ff6cb6815bb26afb92f123b">&#9670;&#160;</a></span>extents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &amp; legate::LogicalStore::extents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the shape of the store. </p>
<p>Flushes the scheduling window if the store is unbound and has no shape assigned.</p>
<dl class="section return"><dt>Returns</dt><dd>The store's shape </dd></dl>

</div>
</div>
<a id="acf035385d22273c70c0ca1f9ff0d8e05" name="acf035385d22273c70c0ca1f9ff0d8e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf035385d22273c70c0ca1f9ff0d8e05">&#9670;&#160;</a></span>get_physical_store()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1PhysicalStore.html">PhysicalStore</a> legate::LogicalStore::get_physical_store </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a physical store for this logical store. </p>
<p>This call blocks the client's control flow and fetches the data for the whole store to the current node</p>
<dl class="section return"><dt>Returns</dt><dd>A physical store of the logical store </dd></dl>

</div>
</div>
<a id="a36410c0eabe00b906769df56ee021f94" name="a36410c0eabe00b906769df56ee021f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36410c0eabe00b906769df56ee021f94">&#9670;&#160;</a></span>has_scalar_storage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a> legate::LogicalStore::has_scalar_storage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether the store's storage is optimized for scalars. </p>
<dl class="section return"><dt>Returns</dt><dd>true The store is backed by a scalar storage </dd>
<dd>
false The store is a backed by a normal region storage </dd></dl>

</div>
</div>
<a id="acd476e18b38c5ac51ecbbd4886fb9315" name="acd476e18b38c5ac51ecbbd4886fb9315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd476e18b38c5ac51ecbbd4886fb9315">&#9670;&#160;</a></span>overlaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a> legate::LogicalStore::overlaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether this store overlaps with a given store. </p>
<dl class="section return"><dt>Returns</dt><dd>true The stores overlap </dd>
<dd>
false The stores are disjoint </dd></dl>

</div>
</div>
<a id="abb057c7b941dbf4e6e9a0fdcb062952b" name="abb057c7b941dbf4e6e9a0fdcb062952b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb057c7b941dbf4e6e9a0fdcb062952b">&#9670;&#160;</a></span>partition_by_tiling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalStorePartition legate::LogicalStore::partition_by_tiling </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">size_t</a> &gt;&#160;</td>
          <td class="paramname"><em>tile_shape</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a tiled partition of the store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile_shape</td><td>Shape of tiles</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A store partition </dd></dl>

</div>
</div>
<a id="a7ef189837b27fe30356ae8b94bd18756" name="a7ef189837b27fe30356ae8b94bd18756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef189837b27fe30356ae8b94bd18756">&#9670;&#160;</a></span>project()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> legate::LogicalStore::project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int64_t</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects out a dimension of the store. </p>
<p>Each dimension \(i\), where \(i\) &gt; <code>dim</code>, is mapped to dimension \(i-1\) in a returned store. A returned store provides a view to the input store where the values are on hyperplane \(x_\mathtt{dim} = \mathtt{index}\).</p>
<p>For example, if a 2D store <code>A</code> contains <code>[[1, 2], [3, 4]]</code>, <code>A.project(0, 1)</code> yields a store equivalent to <code>[3, 4]</code>, whereas <code>A.project(1, 0)</code> yields <code>[1, 3]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>Dimension to project out </td></tr>
    <tr><td class="paramname">index</td><td>Index on the chosen dimension</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new store with one fewer dimension</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If <code>dim</code> is not a valid dimension name or <code>index</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cd14524f3cdb3e83cf29a1492f4f559" name="a4cd14524f3cdb3e83cf29a1492f4f559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd14524f3cdb3e83cf29a1492f4f559">&#9670;&#160;</a></span>promote()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> legate::LogicalStore::promote </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a>&#160;</td>
          <td class="paramname"><em>extra_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">size_t</a>&#160;</td>
          <td class="paramname"><em>dim_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an extra dimension to the store. </p>
<p>Value of <code>extra_dim</code> decides where a new dimension should be added, and each dimension \(i\), where \(i\) &gt;= <code>extra_dim</code>, is mapped to dimension \(i+1\) in a returned store. A returned store provides a view to the input store where the values are broadcasted along the new dimension.</p>
<p>For example, for a 1D store <code>A</code> contains <code>[1, 2, 3]</code>, <code>A.promote(0, 2)</code> yields a store equivalent to:</p>
<div class="fragment"><div class="line">[[1, 2, 3],</div>
<div class="line"> [1, 2, 3]]</div>
</div><!-- fragment --><p>whereas <code>A.promote(1, 2)</code> yields:</p>
<div class="fragment"><div class="line">[[1, 1],</div>
<div class="line"> [2, 2],</div>
<div class="line"> [3, 3]]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extra_dim</td><td>Position for a new dimension </td></tr>
    <tr><td class="paramname">dim_size</td><td>Extent of the new dimension</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new store with an extra dimension</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>When <code>extra_dim</code> is not a valid dimension name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecc89d4f41504681a0595c5e90376741" name="aecc89d4f41504681a0595c5e90376741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc89d4f41504681a0595c5e90376741">&#9670;&#160;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> legate::LogicalStore::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Slice</a>&#160;</td>
          <td class="paramname"><em>sl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slices a contiguous sub-section of the store. </p>
<p>For example, consider a 2D store <code>A</code>:</p>
<div class="fragment"><div class="line">[[1, 2, 3],</div>
<div class="line"> [4, 5, 6],</div>
<div class="line"> [7, 8, 9]]</div>
</div><!-- fragment --><p>A slicing <code>A.slice(0, legate::Slice(1))</code> yields</p>
<div class="fragment"><div class="line">[[4, 5, 6],</div>
<div class="line"> [7, 8, 9]]</div>
</div><!-- fragment --><p>The result store will look like this on a different slicing call <code>A.slice(1, legate::Slice(legate::Slice::OPEN, 2))</code>:</p>
<div class="fragment"><div class="line">[[1, 2],</div>
<div class="line"> [4, 5],</div>
<div class="line"> [7, 8]]</div>
</div><!-- fragment --><p>Finally, chained slicing calls</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">A</a>.slice(0, <a class="code hl_function" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">legate::Slice</a>(1)).slice(1, <a class="code hl_function" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">legate::Slice</a>(legate::Slice::OPEN, 2))</div>
<div class="ttc" id="agroup__data_html_ga655d14b01317cd85edf3433f410fda0d"><div class="ttname"><a href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">legate::create_buffer</a></div><div class="ttdeci">Buffer&lt; VAL, DIM &gt; create_buffer(const Point&lt; DIM &gt; &amp;extents, Memory::Kind kind=Memory::Kind::NO_MEMKIND, size_t alignment=DEFAULT_ALIGNMENT)</div><div class="ttdoc">Creates a Buffer of specific extents.</div><div class="ttdef"><b>Definition</b> buffer.h:74</div></div>
</div><!-- fragment --><p>results in:</p>
<div class="fragment"><div class="line">[[4, 5],</div>
<div class="line"> [7, 8]]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>Dimension to slice </td></tr>
    <tr><td class="paramname">sl</td><td>Slice descriptor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new store that corresponds to the sliced section</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If <code>dim</code> is not a valid dimension name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3624c47c0b0e8167d646a3ff3ff9cf84" name="a3624c47c0b0e8167d646a3ff3ff9cf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3624c47c0b0e8167d646a3ff3ff9cf84">&#9670;&#160;</a></span>transformed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a> legate::LogicalStore::transformed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether the store is transformed. </p>
<dl class="section return"><dt>Returns</dt><dd>true The store is transformed </dd>
<dd>
false The store is not transformed </dd></dl>

</div>
</div>
<a id="aa598551a463bbe85c1dff446579faecc" name="aa598551a463bbe85c1dff446579faecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa598551a463bbe85c1dff446579faecc">&#9670;&#160;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> legate::LogicalStore::transpose </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>axes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders dimensions of the store. </p>
<p>Dimension <code>i</code> of the resulting store is mapped to dimension <code>axes[i]</code> of the input store.</p>
<p>For example, for a 3D store <code>A</code></p>
<div class="fragment"><div class="line">[[[1, 2],</div>
<div class="line">  [3, 4]],</div>
<div class="line"> [[5, 6],</div>
<div class="line">  [7, 8]]]</div>
</div><!-- fragment --><p>transpose calls <code>A.transpose({1, 2, 0})</code> and <code>A.transpose({2, 1, 0})</code> yield the following stores, respectively:</p>
<div class="fragment"><div class="line">[[[1, 5],</div>
<div class="line">  [2, 6]],</div>
<div class="line"> [[3, 7],</div>
<div class="line">  [4, 8]]]</div>
</div><!-- fragment --><div class="fragment"><div class="line">[[[1, 5],</div>
<div class="line"> [3, 7]],</div>
<div class="line"> </div>
<div class="line"> [[2, 6],</div>
<div class="line">  [4, 8]]]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axes</td><td>Mapping from dimensions of the resulting store to those of the input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new store with the dimensions transposed</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If any of the following happens: 1) The length of <code>axes</code> doesn't match the store's dimension; 2) <code>axes</code> has duplicates; 3) Any axis in <code>axes</code> is an invalid axis name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4dc34f63b1a83aa05270e79d59d6fbd5" name="a4dc34f63b1a83aa05270e79d59d6fbd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc34f63b1a83aa05270e79d59d6fbd5">&#9670;&#160;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1Type.html">Type</a> legate::LogicalStore::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the element type of the store. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlegate_1_1Type.html" title="A base class for data type metadata.">Type</a> of elements in the store </dd></dl>

</div>
</div>
<a id="aa631a7c6fc21a2354c8742b2556207a7" name="aa631a7c6fc21a2354c8742b2556207a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa631a7c6fc21a2354c8742b2556207a7">&#9670;&#160;</a></span>unbound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a> legate::LogicalStore::unbound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether the store is unbound. </p>
<dl class="section return"><dt>Returns</dt><dd>true The store is unbound </dd>
<dd>
false The store is normal </dd></dl>

</div>
</div>
<a id="a11c29db25efa34cbaa864b53f5678f28" name="a11c29db25efa34cbaa864b53f5678f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c29db25efa34cbaa864b53f5678f28">&#9670;&#160;</a></span>volume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">size_t</a> legate::LogicalStore::volume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements in the store. </p>
<p>Flushes the scheduling window if the store is unbound and has no shape assigned.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the store </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="logical__store_8h_source.html">logical_store.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
