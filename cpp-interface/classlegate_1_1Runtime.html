<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Legate: legate::Runtime Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Legate<span id="projectnumber">&#160;24.01.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>legate</b></li><li class="navelem"><a class="el" href="classlegate_1_1Runtime.html">Runtime</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classlegate_1_1Runtime-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">legate::Runtime Class Reference<div class="ingroups"><a class="el" href="group__runtime.html">Runtime and library contexts</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Class that implements the Legate runtime.  
 <a href="classlegate_1_1Runtime.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="runtime_8h_source.html">core/runtime/runtime.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e7579cc7f75978c325fff9f7bba0065" id="r_a3e7579cc7f75978c325fff9f7bba0065"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1Library.html">Library</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a3e7579cc7f75978c325fff9f7bba0065">create_library</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> std::string &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">library_name</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">ResourceConfig</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">config</a>=<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">ResourceConfig</a>{}, std::unique_ptr&lt; <a class="el" href="classlegate_1_1mapping_1_1Mapper.html">mapping::Mapper</a> &gt; <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">mapper</a>=<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">nullptr</a>)</td></tr>
<tr class="memdesc:a3e7579cc7f75978c325fff9f7bba0065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a library.  <br /></td></tr>
<tr class="separator:a3e7579cc7f75978c325fff9f7bba0065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4c87d146e88d86cc1d907d934c770e" id="r_a1a4c87d146e88d86cc1d907d934c770e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1Library.html">Library</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a1a4c87d146e88d86cc1d907d934c770e">find_library</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> std::string &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">library_name</a>) <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a></td></tr>
<tr class="memdesc:a1a4c87d146e88d86cc1d907d934c770e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a library.  <br /></td></tr>
<tr class="separator:a1a4c87d146e88d86cc1d907d934c770e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f1b1a0680f90f4a0ca579a7b95d65a" id="r_a69f1b1a0680f90f4a0ca579a7b95d65a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classlegate_1_1Library.html">Library</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a69f1b1a0680f90f4a0ca579a7b95d65a">maybe_find_library</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> std::string &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">library_name</a>) <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a></td></tr>
<tr class="memdesc:a69f1b1a0680f90f4a0ca579a7b95d65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find a library.  <br /></td></tr>
<tr class="separator:a69f1b1a0680f90f4a0ca579a7b95d65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198c16ced3b871afea384b481f7e928a" id="r_a198c16ced3b871afea384b481f7e928a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1Library.html">Library</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a198c16ced3b871afea384b481f7e928a">find_or_create_library</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> std::string &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">library_name</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">ResourceConfig</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">config</a>=<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">ResourceConfig</a>{}, std::unique_ptr&lt; <a class="el" href="classlegate_1_1mapping_1_1Mapper.html">mapping::Mapper</a> &gt; <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">mapper</a>=<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">nullptr</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a> *<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">created</a>=<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">nullptr</a>)</td></tr>
<tr class="memdesc:a198c16ced3b871afea384b481f7e928a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds or creates a library.  <br /></td></tr>
<tr class="separator:a198c16ced3b871afea384b481f7e928a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85bed0e7af522a2eb3a737a60e0b5fd" id="r_aa85bed0e7af522a2eb3a737a60e0b5fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1AutoTask.html">AutoTask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#aa85bed0e7af522a2eb3a737a60e0b5fd">create_task</a> (<a class="el" href="classlegate_1_1Library.html">Library</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">library</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int64_t</a> task_id)</td></tr>
<tr class="memdesc:aa85bed0e7af522a2eb3a737a60e0b5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classlegate_1_1AutoTask.html" title="A class for auto-parallelized task desciptors.">AutoTask</a>.  <br /></td></tr>
<tr class="separator:aa85bed0e7af522a2eb3a737a60e0b5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9f8bcb8858e74d5441f839d6942198" id="r_a7f9f8bcb8858e74d5441f839d6942198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1ManualTask.html">ManualTask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a7f9f8bcb8858e74d5441f839d6942198">create_task</a> (<a class="el" href="classlegate_1_1Library.html">Library</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">library</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int64_t</a> task_id, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">launch_shape</a>)</td></tr>
<tr class="memdesc:a7f9f8bcb8858e74d5441f839d6942198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classlegate_1_1ManualTask.html" title="A class for manually parallelized task descriptors.">ManualTask</a>.  <br /></td></tr>
<tr class="separator:a7f9f8bcb8858e74d5441f839d6942198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05167931603d98f112b68998d6be532e" id="r_a05167931603d98f112b68998d6be532e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1ManualTask.html">ManualTask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a05167931603d98f112b68998d6be532e">create_task</a> (<a class="el" href="classlegate_1_1Library.html">Library</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">library</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int64_t</a> task_id, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__geometry.html#ga63715b9851081550bed4579f8dcdf2af">Domain</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">launch_domain</a>)</td></tr>
<tr class="memdesc:a05167931603d98f112b68998d6be532e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classlegate_1_1ManualTask.html" title="A class for manually parallelized task descriptors.">ManualTask</a>.  <br /></td></tr>
<tr class="separator:a05167931603d98f112b68998d6be532e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39cd813542d5c291a4db065ba836e13" id="r_ac39cd813542d5c291a4db065ba836e13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#ac39cd813542d5c291a4db065ba836e13">issue_copy</a> (<a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;target, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">source</a>, std::optional&lt; <a class="el" href="group__types.html#gaf066ee3ee59b3247104e036a26e52525">ReductionOpKind</a> &gt; redop=std::nullopt)</td></tr>
<tr class="memdesc:ac39cd813542d5c291a4db065ba836e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a copy between stores.  <br /></td></tr>
<tr class="separator:ac39cd813542d5c291a4db065ba836e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa414fce4f0f3a013dc158166918982b5" id="r_aa414fce4f0f3a013dc158166918982b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#aa414fce4f0f3a013dc158166918982b5">issue_copy</a> (<a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;target, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">source</a>, std::optional&lt; <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a> &gt; redop)</td></tr>
<tr class="memdesc:aa414fce4f0f3a013dc158166918982b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a copy between stores.  <br /></td></tr>
<tr class="separator:aa414fce4f0f3a013dc158166918982b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c37be0dcdd6d0423839f16024541f7" id="r_a68c37be0dcdd6d0423839f16024541f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a68c37be0dcdd6d0423839f16024541f7">issue_gather</a> (<a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;target, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">source</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">source_indirect</a>, std::optional&lt; <a class="el" href="group__types.html#gaf066ee3ee59b3247104e036a26e52525">ReductionOpKind</a> &gt; redop=std::nullopt)</td></tr>
<tr class="memdesc:a68c37be0dcdd6d0423839f16024541f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a gather copy between stores.  <br /></td></tr>
<tr class="separator:a68c37be0dcdd6d0423839f16024541f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f4fd6bb0629d8c68d1b61f91f12405" id="r_a14f4fd6bb0629d8c68d1b61f91f12405"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a14f4fd6bb0629d8c68d1b61f91f12405">issue_gather</a> (<a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;target, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">source</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">source_indirect</a>, std::optional&lt; <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a> &gt; redop)</td></tr>
<tr class="memdesc:a14f4fd6bb0629d8c68d1b61f91f12405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a gather copy between stores.  <br /></td></tr>
<tr class="separator:a14f4fd6bb0629d8c68d1b61f91f12405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad738289cb4ab668259453be1e3337c2f" id="r_ad738289cb4ab668259453be1e3337c2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#ad738289cb4ab668259453be1e3337c2f">issue_scatter</a> (<a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;target, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">target_indirect</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">source</a>, std::optional&lt; <a class="el" href="group__types.html#gaf066ee3ee59b3247104e036a26e52525">ReductionOpKind</a> &gt; redop=std::nullopt)</td></tr>
<tr class="memdesc:ad738289cb4ab668259453be1e3337c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a scatter copy between stores.  <br /></td></tr>
<tr class="separator:ad738289cb4ab668259453be1e3337c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d5f2fb683c13c9583584b1cacc285e" id="r_a22d5f2fb683c13c9583584b1cacc285e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a22d5f2fb683c13c9583584b1cacc285e">issue_scatter</a> (<a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;target, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">target_indirect</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">source</a>, std::optional&lt; <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a> &gt; redop)</td></tr>
<tr class="memdesc:a22d5f2fb683c13c9583584b1cacc285e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a scatter copy between stores.  <br /></td></tr>
<tr class="separator:a22d5f2fb683c13c9583584b1cacc285e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64512438655e1df2317760ad0f362710" id="r_a64512438655e1df2317760ad0f362710"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a64512438655e1df2317760ad0f362710">issue_scatter_gather</a> (<a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;target, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">target_indirect</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">source</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">source_indirect</a>, std::optional&lt; <a class="el" href="group__types.html#gaf066ee3ee59b3247104e036a26e52525">ReductionOpKind</a> &gt; redop=std::nullopt)</td></tr>
<tr class="memdesc:a64512438655e1df2317760ad0f362710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a scatter-gather copy between stores.  <br /></td></tr>
<tr class="separator:a64512438655e1df2317760ad0f362710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4485bb806540bdf82cb280e8f3925def" id="r_a4485bb806540bdf82cb280e8f3925def"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a4485bb806540bdf82cb280e8f3925def">issue_scatter_gather</a> (<a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;target, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">target_indirect</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">source</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">source_indirect</a>, std::optional&lt; <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a> &gt; redop)</td></tr>
<tr class="memdesc:a4485bb806540bdf82cb280e8f3925def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a scatter-gather copy between stores.  <br /></td></tr>
<tr class="separator:a4485bb806540bdf82cb280e8f3925def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833ad58d72b2f63d97d611e64d61707b" id="r_a833ad58d72b2f63d97d611e64d61707b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a833ad58d72b2f63d97d611e64d61707b">issue_fill</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">lhs</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;value)</td></tr>
<tr class="memdesc:a833ad58d72b2f63d97d611e64d61707b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a given array with a constant.  <br /></td></tr>
<tr class="separator:a833ad58d72b2f63d97d611e64d61707b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6c33cbccba7c9eee327166c99d8fb6" id="r_abf6c33cbccba7c9eee327166c99d8fb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#abf6c33cbccba7c9eee327166c99d8fb6">issue_fill</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">lhs</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1Scalar.html">Scalar</a> &amp;value)</td></tr>
<tr class="memdesc:abf6c33cbccba7c9eee327166c99d8fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a given array with a constant.  <br /></td></tr>
<tr class="separator:abf6c33cbccba7c9eee327166c99d8fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96e6b441e6c225a9a7508f1f91c8122" id="r_ab96e6b441e6c225a9a7508f1f91c8122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#ab96e6b441e6c225a9a7508f1f91c8122">tree_reduce</a> (<a class="el" href="classlegate_1_1Library.html">Library</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">library</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int64_t</a> task_id, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;store, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">radix</a>=4)</td></tr>
<tr class="memdesc:ab96e6b441e6c225a9a7508f1f91c8122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs reduction on a given store via a task.  <br /></td></tr>
<tr class="separator:ab96e6b441e6c225a9a7508f1f91c8122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9a69f276edfdef8c2221cacb4c811c" id="r_aeb9a69f276edfdef8c2221cacb4c811c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#aeb9a69f276edfdef8c2221cacb4c811c">submit</a> (<a class="el" href="classlegate_1_1AutoTask.html">AutoTask</a> task)</td></tr>
<tr class="memdesc:aeb9a69f276edfdef8c2221cacb4c811c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits an <a class="el" href="classlegate_1_1AutoTask.html" title="A class for auto-parallelized task desciptors.">AutoTask</a> for execution.  <br /></td></tr>
<tr class="separator:aeb9a69f276edfdef8c2221cacb4c811c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f15f26d31e9400f1e6e5feef0c697d" id="r_ad5f15f26d31e9400f1e6e5feef0c697d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#ad5f15f26d31e9400f1e6e5feef0c697d">submit</a> (<a class="el" href="classlegate_1_1ManualTask.html">ManualTask</a> task)</td></tr>
<tr class="memdesc:ad5f15f26d31e9400f1e6e5feef0c697d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a <a class="el" href="classlegate_1_1ManualTask.html" title="A class for manually parallelized task descriptors.">ManualTask</a> for execution.  <br /></td></tr>
<tr class="separator:ad5f15f26d31e9400f1e6e5feef0c697d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bada4eded44bb2940dd205f905551d9" id="r_a8bada4eded44bb2940dd205f905551d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a8bada4eded44bb2940dd205f905551d9">create_array</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1Type.html">Type</a> &amp;type, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">uint32_t</a> dim=1, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a> nullable=<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">false</a>)</td></tr>
<tr class="memdesc:a8bada4eded44bb2940dd205f905551d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an unbound array.  <br /></td></tr>
<tr class="separator:a8bada4eded44bb2940dd205f905551d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641a60dc59693c7576cf040931e3154a" id="r_a641a60dc59693c7576cf040931e3154a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a641a60dc59693c7576cf040931e3154a">create_array</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &amp;extents, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1Type.html">Type</a> &amp;type, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a> nullable=<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">false</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">optimize_scalar</a>=<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">false</a>)</td></tr>
<tr class="memdesc:a641a60dc59693c7576cf040931e3154a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a normal array.  <br /></td></tr>
<tr class="separator:a641a60dc59693c7576cf040931e3154a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1b1bef6348d20964e7949c07e2dd30" id="r_add1b1bef6348d20964e7949c07e2dd30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#add1b1bef6348d20964e7949c07e2dd30">create_array_like</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">to_mirror</a>, std::optional&lt; <a class="el" href="classlegate_1_1Type.html">Type</a> &gt; type=std::nullopt)</td></tr>
<tr class="memdesc:add1b1bef6348d20964e7949c07e2dd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an array isomorphic to the given array.  <br /></td></tr>
<tr class="separator:add1b1bef6348d20964e7949c07e2dd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ea6722a1190e42f72fcfbf16cbf841" id="r_a80ea6722a1190e42f72fcfbf16cbf841"><td class="memItemLeft" align="right" valign="top">StringLogicalArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a80ea6722a1190e42f72fcfbf16cbf841">create_string_array</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a> &amp;descriptor, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a> &amp;vardata)</td></tr>
<tr class="memdesc:a80ea6722a1190e42f72fcfbf16cbf841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string array from the existing sub-arrays.  <br /></td></tr>
<tr class="separator:a80ea6722a1190e42f72fcfbf16cbf841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779b31e4ea65c1e73e61508a38d728b9" id="r_a779b31e4ea65c1e73e61508a38d728b9"><td class="memItemLeft" align="right" valign="top">ListLogicalArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a779b31e4ea65c1e73e61508a38d728b9">create_list_array</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a> &amp;descriptor, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a> &amp;vardata, std::optional&lt; <a class="el" href="classlegate_1_1Type.html">Type</a> &gt; type=std::nullopt)</td></tr>
<tr class="memdesc:a779b31e4ea65c1e73e61508a38d728b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a list array from the existing sub-arrays.  <br /></td></tr>
<tr class="separator:a779b31e4ea65c1e73e61508a38d728b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc039782a514946325a20bded2e5887" id="r_a4bc039782a514946325a20bded2e5887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a4bc039782a514946325a20bded2e5887">create_store</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1Type.html">Type</a> &amp;type, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">uint32_t</a> dim=1)</td></tr>
<tr class="memdesc:a4bc039782a514946325a20bded2e5887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an unbound store.  <br /></td></tr>
<tr class="separator:a4bc039782a514946325a20bded2e5887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf36e374e4caf2f7e4f095c851247ed7" id="r_aaf36e374e4caf2f7e4f095c851247ed7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#aaf36e374e4caf2f7e4f095c851247ed7">create_store</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &amp;extents, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1Type.html">Type</a> &amp;type, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">optimize_scalar</a>=<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">false</a>)</td></tr>
<tr class="memdesc:aaf36e374e4caf2f7e4f095c851247ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a normal store.  <br /></td></tr>
<tr class="separator:aaf36e374e4caf2f7e4f095c851247ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b707b1ed2b3522b2cb0b7df5ab101d" id="r_a59b707b1ed2b3522b2cb0b7df5ab101d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a59b707b1ed2b3522b2cb0b7df5ab101d">create_store</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1Scalar.html">Scalar</a> &amp;scalar, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &amp;extents=<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a>{1})</td></tr>
<tr class="memdesc:a59b707b1ed2b3522b2cb0b7df5ab101d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a normal store out of a <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars.">Scalar</a></code> object.  <br /></td></tr>
<tr class="separator:a59b707b1ed2b3522b2cb0b7df5ab101d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19402525d2b590d7c80561075a61007a" id="r_a19402525d2b590d7c80561075a61007a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a19402525d2b590d7c80561075a61007a">create_store</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &amp;extents, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1Type.html">Type</a> &amp;type, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a> *<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">buffer</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a> read_only=<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">true</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="structlegate_1_1mapping_1_1DimOrdering.html">mapping::DimOrdering</a> &amp;ordering=<a class="el" href="structlegate_1_1mapping_1_1DimOrdering.html#a6e6575e8332a1f20ad54eb008ef79766">mapping::DimOrdering::c_order</a>())</td></tr>
<tr class="memdesc:a19402525d2b590d7c80561075a61007a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a store by attaching to an existing allocation.  <br /></td></tr>
<tr class="separator:a19402525d2b590d7c80561075a61007a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d6a30d0d6bf27220d7997fa387783a" id="r_aa2d6a30d0d6bf27220d7997fa387783a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#aa2d6a30d0d6bf27220d7997fa387783a">create_store</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &amp;extents, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1Type.html">Type</a> &amp;type, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1ExternalAllocation.html">ExternalAllocation</a> &amp;allocation, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="structlegate_1_1mapping_1_1DimOrdering.html">mapping::DimOrdering</a> &amp;ordering=<a class="el" href="structlegate_1_1mapping_1_1DimOrdering.html#a6e6575e8332a1f20ad54eb008ef79766">mapping::DimOrdering::c_order</a>())</td></tr>
<tr class="memdesc:aa2d6a30d0d6bf27220d7997fa387783a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a store by attaching to an existing allocation.  <br /></td></tr>
<tr class="separator:aa2d6a30d0d6bf27220d7997fa387783a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e800f96c8627d63be31c531d808ec92" id="r_a0e800f96c8627d63be31c531d808ec92"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a>, LogicalStorePartition &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a0e800f96c8627d63be31c531d808ec92">create_store</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &amp;extents, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">tile_shape</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1Type.html">Type</a> &amp;type, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> std::vector&lt; std::pair&lt; <a class="el" href="classlegate_1_1ExternalAllocation.html">ExternalAllocation</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &gt; &gt; &amp;<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">allocations</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="structlegate_1_1mapping_1_1DimOrdering.html">mapping::DimOrdering</a> &amp;ordering=<a class="el" href="structlegate_1_1mapping_1_1DimOrdering.html#a6e6575e8332a1f20ad54eb008ef79766">mapping::DimOrdering::c_order</a>())</td></tr>
<tr class="memdesc:a0e800f96c8627d63be31c531d808ec92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a store by attaching to multiple existing allocations.  <br /></td></tr>
<tr class="separator:a0e800f96c8627d63be31c531d808ec92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee58f31c99882ddd268c3f52e4ee3055" id="r_aee58f31c99882ddd268c3f52e4ee3055"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#aee58f31c99882ddd268c3f52e4ee3055">issue_execution_fence</a> (<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">block</a>=<a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">false</a>)</td></tr>
<tr class="memdesc:aee58f31c99882ddd268c3f52e4ee3055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues an execution fence.  <br /></td></tr>
<tr class="separator:aee58f31c99882ddd268c3f52e4ee3055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e48daaaa5194c7c0f72e0a8d13d4c2" id="r_ab2e48daaaa5194c7c0f72e0a8d13d4c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlegate_1_1mapping_1_1Machine.html">mapping::Machine</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#ab2e48daaaa5194c7c0f72e0a8d13d4c2">get_machine</a> () <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a></td></tr>
<tr class="memdesc:ab2e48daaaa5194c7c0f72e0a8d13d4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the machine of the current scope.  <br /></td></tr>
<tr class="separator:ab2e48daaaa5194c7c0f72e0a8d13d4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a13220f54823c9787ddc15bb5a2c25598" id="r_a13220f54823c9787ddc15bb5a2c25598"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">static</a> <a class="el" href="classlegate_1_1Runtime.html">Runtime</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Runtime.html#a13220f54823c9787ddc15bb5a2c25598">get_runtime</a> ()</td></tr>
<tr class="memdesc:a13220f54823c9787ddc15bb5a2c25598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a singleton runtime object.  <br /></td></tr>
<tr class="separator:a13220f54823c9787ddc15bb5a2c25598"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class that implements the Legate runtime. </p>
<p>The legate runtime provides common services, including as library registration, store creation, operator creation and submission, resource management and scoping, and communicator management. Legate libraries are free of all these details about distribute programming and can focus on their domain logics. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a641a60dc59693c7576cf040931e3154a" name="a641a60dc59693c7576cf040931e3154a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641a60dc59693c7576cf040931e3154a">&#9670;&#160;</a></span>create_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a> legate::Runtime::create_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a>&#160;</td>
          <td class="paramname"><em>nullable</em> = <code><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a>&#160;</td>
          <td class="paramname"><em>optimize_scalar</em> = <code><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a normal array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extents</td><td>Shape of the array </td></tr>
    <tr><td class="paramname">type</td><td>Element type </td></tr>
    <tr><td class="paramname">nullable</td><td>Nullability of the array </td></tr>
    <tr><td class="paramname">optimize_scalar</td><td>When true, the runtime internally uses futures optimized for storing scalars</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Logical array </dd></dl>

</div>
</div>
<a id="a8bada4eded44bb2940dd205f905551d9" name="a8bada4eded44bb2940dd205f905551d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bada4eded44bb2940dd205f905551d9">&#9670;&#160;</a></span>create_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a> legate::Runtime::create_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">uint32_t</a>&#160;</td>
          <td class="paramname"><em>dim</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a>&#160;</td>
          <td class="paramname"><em>nullable</em> = <code><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an unbound array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Element type </td></tr>
    <tr><td class="paramname">dim</td><td>Number of dimensions </td></tr>
    <tr><td class="paramname">nullable</td><td>Nullability of the array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Logical array </dd></dl>

</div>
</div>
<a id="add1b1bef6348d20964e7949c07e2dd30" name="add1b1bef6348d20964e7949c07e2dd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1b1bef6348d20964e7949c07e2dd30">&#9670;&#160;</a></span>create_array_like()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a> legate::Runtime::create_array_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a> &amp;&#160;</td>
          <td class="paramname"><em>to_mirror</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classlegate_1_1Type.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>type</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an array isomorphic to the given array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_mirror</td><td>The array whose shape would be used to create the output array. </td></tr>
    <tr><td class="paramname">type</td><td>Optional type for the resulting array. Must be compatible with the input array's type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Logical array isomorphic to the input </dd></dl>

</div>
</div>
<a id="a3e7579cc7f75978c325fff9f7bba0065" name="a3e7579cc7f75978c325fff9f7bba0065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7579cc7f75978c325fff9f7bba0065">&#9670;&#160;</a></span>create_library()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1Library.html">Library</a> legate::Runtime::create_library </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>library_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">ResourceConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">ResourceConfig</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classlegate_1_1mapping_1_1Mapper.html">mapping::Mapper</a> &gt;&#160;</td>
          <td class="paramname"><em>mapper</em> = <code><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">nullptr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a library. </p>
<p>A library is a collection of tasks and custom reduction operators. The maximum number of tasks and reduction operators can be optionally specified with a <code>ResourceConfig</code> object. Each library can optionally have a mapper that specifies mapping policies for its tasks. When no mapper is given, the default mapper is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">library_name</td><td><a class="el" href="classlegate_1_1Library.html" title="A library class that provides APIs for registering components.">Library</a> name. Must be unique to this library </td></tr>
    <tr><td class="paramname">config</td><td>Optional configuration object </td></tr>
    <tr><td class="paramname">mapper</td><td>Optional mapper object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlegate_1_1Library.html" title="A library class that provides APIs for registering components.">Library</a> object</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If a library already exists for a given name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a779b31e4ea65c1e73e61508a38d728b9" name="a779b31e4ea65c1e73e61508a38d728b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779b31e4ea65c1e73e61508a38d728b9">&#9670;&#160;</a></span>create_list_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ListLogicalArray legate::Runtime::create_list_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a> &amp;&#160;</td>
          <td class="paramname"><em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a> &amp;&#160;</td>
          <td class="paramname"><em>vardata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classlegate_1_1Type.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>type</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a list array from the existing sub-arrays. </p>
<p>The caller is responsible for making sure that the vardata sub-array is valid for all the descriptors in the descriptor sub-array</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descriptor</td><td>Sub-array for descriptors </td></tr>
    <tr><td class="paramname">vardata</td><td>Sub-array for vardata </td></tr>
    <tr><td class="paramname">type</td><td>Optional list type the returned array would have</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List logical array</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>When any of the following is true: 1) <code>type</code> is not a list type 2) <code>descriptor</code> or <code>vardata</code> is unbound or N-D where N &gt; 1 3) <code>descriptor</code> does not have a 1D rect type 4) <code>vardata</code> is nullable 5) <code>vardata</code> and <code>type</code> have different element types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59b707b1ed2b3522b2cb0b7df5ab101d" name="a59b707b1ed2b3522b2cb0b7df5ab101d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b707b1ed2b3522b2cb0b7df5ab101d">&#9670;&#160;</a></span>create_store() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> legate::Runtime::create_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1Scalar.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>extents</em> = <code><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a>{1}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a normal store out of a <code><a class="el" href="classlegate_1_1Scalar.html" title="A type-erased container for scalars.">Scalar</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Value of the scalar to create a store with </td></tr>
    <tr><td class="paramname">extents</td><td>Shape of the store. The volume must be 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Logical store </dd></dl>

</div>
</div>
<a id="a0e800f96c8627d63be31c531d808ec92" name="a0e800f96c8627d63be31c531d808ec92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e800f96c8627d63be31c531d808ec92">&#9670;&#160;</a></span>create_store() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a>, LogicalStorePartition &gt; legate::Runtime::create_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>tile_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> std::vector&lt; std::pair&lt; <a class="el" href="classlegate_1_1ExternalAllocation.html">ExternalAllocation</a>, <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>allocations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="structlegate_1_1mapping_1_1DimOrdering.html">mapping::DimOrdering</a> &amp;&#160;</td>
          <td class="paramname"><em>ordering</em> = <code><a class="el" href="structlegate_1_1mapping_1_1DimOrdering.html#a6e6575e8332a1f20ad54eb008ef79766">mapping::DimOrdering::c_order</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a store by attaching to multiple existing allocations. </p>
<p>External allocations must be read-only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extents</td><td>Shape of the store </td></tr>
    <tr><td class="paramname">tile_shape</td><td>Shape of tiles </td></tr>
    <tr><td class="paramname">type</td><td>Element type </td></tr>
    <tr><td class="paramname">allocations</td><td>Pairs of external allocation descriptors and sub-store colors </td></tr>
    <tr><td class="paramname">ordering</td><td>In what order the elements are laid out in the passed allocatios</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of a logical store and its partition</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If any of the external allocations are not read-only </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf36e374e4caf2f7e4f095c851247ed7" name="aaf36e374e4caf2f7e4f095c851247ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf36e374e4caf2f7e4f095c851247ed7">&#9670;&#160;</a></span>create_store() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> legate::Runtime::create_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a>&#160;</td>
          <td class="paramname"><em>optimize_scalar</em> = <code><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a normal store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extents</td><td>Shape of the store </td></tr>
    <tr><td class="paramname">type</td><td>Element type </td></tr>
    <tr><td class="paramname">optimize_scalar</td><td>When true, the runtime internally uses futures optimized for storing scalars</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Logical store </dd></dl>

</div>
</div>
<a id="aa2d6a30d0d6bf27220d7997fa387783a" name="aa2d6a30d0d6bf27220d7997fa387783a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d6a30d0d6bf27220d7997fa387783a">&#9670;&#160;</a></span>create_store() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> legate::Runtime::create_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1ExternalAllocation.html">ExternalAllocation</a> &amp;&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="structlegate_1_1mapping_1_1DimOrdering.html">mapping::DimOrdering</a> &amp;&#160;</td>
          <td class="paramname"><em>ordering</em> = <code><a class="el" href="structlegate_1_1mapping_1_1DimOrdering.html#a6e6575e8332a1f20ad54eb008ef79766">mapping::DimOrdering::c_order</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a store by attaching to an existing allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extents</td><td>Shape of the store </td></tr>
    <tr><td class="paramname">type</td><td>Element type </td></tr>
    <tr><td class="paramname">allocation</td><td>External allocation descriptor </td></tr>
    <tr><td class="paramname">ordering</td><td>In what order the elements are laid out in the passed allocation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Logical store </dd></dl>

</div>
</div>
<a id="a19402525d2b590d7c80561075a61007a" name="a19402525d2b590d7c80561075a61007a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19402525d2b590d7c80561075a61007a">&#9670;&#160;</a></span>create_store() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> legate::Runtime::create_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a>&#160;</td>
          <td class="paramname"><em>read_only</em> = <code><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="structlegate_1_1mapping_1_1DimOrdering.html">mapping::DimOrdering</a> &amp;&#160;</td>
          <td class="paramname"><em>ordering</em> = <code><a class="el" href="structlegate_1_1mapping_1_1DimOrdering.html#a6e6575e8332a1f20ad54eb008ef79766">mapping::DimOrdering::c_order</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a store by attaching to an existing allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extents</td><td>Shape of the store </td></tr>
    <tr><td class="paramname">type</td><td>Element type </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to the beginning of the allocation to attach to; allocation must be contiguous, and cover the entire contents of the store (at least <code>extents.volume() * type.size()</code> bytes) </td></tr>
    <tr><td class="paramname">read_only</td><td>Whether the allocation is read-only </td></tr>
    <tr><td class="paramname">ordering</td><td>In what order the elements are laid out in the passed buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Logical store </dd></dl>

</div>
</div>
<a id="a4bc039782a514946325a20bded2e5887" name="a4bc039782a514946325a20bded2e5887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc039782a514946325a20bded2e5887">&#9670;&#160;</a></span>create_store() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> legate::Runtime::create_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">uint32_t</a>&#160;</td>
          <td class="paramname"><em>dim</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an unbound store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Element type </td></tr>
    <tr><td class="paramname">dim</td><td>Number of dimensions of the store</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Logical store </dd></dl>

</div>
</div>
<a id="a80ea6722a1190e42f72fcfbf16cbf841" name="a80ea6722a1190e42f72fcfbf16cbf841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ea6722a1190e42f72fcfbf16cbf841">&#9670;&#160;</a></span>create_string_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringLogicalArray legate::Runtime::create_string_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a> &amp;&#160;</td>
          <td class="paramname"><em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a> &amp;&#160;</td>
          <td class="paramname"><em>vardata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string array from the existing sub-arrays. </p>
<p>The caller is responsible for making sure that the vardata sub-array is valid for all the descriptors in the descriptor sub-array</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descriptor</td><td>Sub-array for descriptors </td></tr>
    <tr><td class="paramname">vardata</td><td>Sub-array for characters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String logical array</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>When any of the following is true: 1) <code>descriptor</code> or <code>vardata</code> is unbound or N-D where N &gt; 1 2) <code>descriptor</code> does not have a 1D rect type 3) <code>vardata</code> is nullable 4) <code>vardata</code> does not have an int8 type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa85bed0e7af522a2eb3a737a60e0b5fd" name="aa85bed0e7af522a2eb3a737a60e0b5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85bed0e7af522a2eb3a737a60e0b5fd">&#9670;&#160;</a></span>create_task() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1AutoTask.html">AutoTask</a> legate::Runtime::create_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlegate_1_1Library.html">Library</a>&#160;</td>
          <td class="paramname"><em>library</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int64_t</a>&#160;</td>
          <td class="paramname"><em>task_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classlegate_1_1AutoTask.html" title="A class for auto-parallelized task desciptors.">AutoTask</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">library</td><td><a class="el" href="classlegate_1_1Library.html" title="A library class that provides APIs for registering components.">Library</a> to query the task </td></tr>
    <tr><td class="paramname">task_id</td><td>Library-local Task ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Task object </dd></dl>

</div>
</div>
<a id="a05167931603d98f112b68998d6be532e" name="a05167931603d98f112b68998d6be532e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05167931603d98f112b68998d6be532e">&#9670;&#160;</a></span>create_task() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1ManualTask.html">ManualTask</a> legate::Runtime::create_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlegate_1_1Library.html">Library</a>&#160;</td>
          <td class="paramname"><em>library</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int64_t</a>&#160;</td>
          <td class="paramname"><em>task_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__geometry.html#ga63715b9851081550bed4579f8dcdf2af">Domain</a> &amp;&#160;</td>
          <td class="paramname"><em>launch_domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classlegate_1_1ManualTask.html" title="A class for manually parallelized task descriptors.">ManualTask</a>. </p>
<p>This overload should be used when the lower bounds of the task's launch domain should be non-zero. Note that the upper bounds of the launch domain are inclusive (whereas the <code>launch_shape</code> in the other overload is exlusive).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">library</td><td><a class="el" href="classlegate_1_1Library.html" title="A library class that provides APIs for registering components.">Library</a> to query the task </td></tr>
    <tr><td class="paramname">task_id</td><td>Library-local Task ID </td></tr>
    <tr><td class="paramname">launch_domain</td><td>Launch domain for the task</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Task object </dd></dl>

</div>
</div>
<a id="a7f9f8bcb8858e74d5441f839d6942198" name="a7f9f8bcb8858e74d5441f839d6942198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9f8bcb8858e74d5441f839d6942198">&#9670;&#160;</a></span>create_task() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1ManualTask.html">ManualTask</a> legate::Runtime::create_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlegate_1_1Library.html">Library</a>&#160;</td>
          <td class="paramname"><em>library</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int64_t</a>&#160;</td>
          <td class="paramname"><em>task_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>launch_shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classlegate_1_1ManualTask.html" title="A class for manually parallelized task descriptors.">ManualTask</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">library</td><td><a class="el" href="classlegate_1_1Library.html" title="A library class that provides APIs for registering components.">Library</a> to query the task </td></tr>
    <tr><td class="paramname">task_id</td><td>Library-local Task ID </td></tr>
    <tr><td class="paramname">launch_shape</td><td>Launch domain for the task</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Task object </dd></dl>

</div>
</div>
<a id="a1a4c87d146e88d86cc1d907d934c770e" name="a1a4c87d146e88d86cc1d907d934c770e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4c87d146e88d86cc1d907d934c770e">&#9670;&#160;</a></span>find_library()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1Library.html">Library</a> legate::Runtime::find_library </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>library_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">library_name</td><td><a class="el" href="classlegate_1_1Library.html" title="A library class that provides APIs for registering components.">Library</a> name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlegate_1_1Library.html" title="A library class that provides APIs for registering components.">Library</a> object</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If no library is found for a given name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a198c16ced3b871afea384b481f7e928a" name="a198c16ced3b871afea384b481f7e928a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a198c16ced3b871afea384b481f7e928a">&#9670;&#160;</a></span>find_or_create_library()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1Library.html">Library</a> legate::Runtime::find_or_create_library </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>library_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">ResourceConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">ResourceConfig</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classlegate_1_1mapping_1_1Mapper.html">mapping::Mapper</a> &gt;&#160;</td>
          <td class="paramname"><em>mapper</em> = <code><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">nullptr</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a> *&#160;</td>
          <td class="paramname"><em>created</em> = <code><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">nullptr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds or creates a library. </p>
<p>The optional configuration and mapper objects are picked up only when the library is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">library_name</td><td><a class="el" href="classlegate_1_1Library.html" title="A library class that provides APIs for registering components.">Library</a> name. Must be unique to this library </td></tr>
    <tr><td class="paramname">config</td><td>Optional configuration object </td></tr>
    <tr><td class="paramname">mapper</td><td>Optional mapper object </td></tr>
    <tr><td class="paramname">created</td><td>Optional pointer to a boolean flag indicating whether the library has been created because of this call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Context object for the library </dd></dl>

</div>
</div>
<a id="ab2e48daaaa5194c7c0f72e0a8d13d4c2" name="ab2e48daaaa5194c7c0f72e0a8d13d4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e48daaaa5194c7c0f72e0a8d13d4c2">&#9670;&#160;</a></span>get_machine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1mapping_1_1Machine.html">mapping::Machine</a> legate::Runtime::get_machine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the machine of the current scope. </p>
<dl class="section return"><dt>Returns</dt><dd>Machine object </dd></dl>

</div>
</div>
<a id="a13220f54823c9787ddc15bb5a2c25598" name="a13220f54823c9787ddc15bb5a2c25598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13220f54823c9787ddc15bb5a2c25598">&#9670;&#160;</a></span>get_runtime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">static</a> <a class="el" href="classlegate_1_1Runtime.html">Runtime</a> * legate::Runtime::get_runtime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a singleton runtime object. </p>
<dl class="section return"><dt>Returns</dt><dd>The runtime object </dd></dl>

</div>
</div>
<a id="aa414fce4f0f3a013dc158166918982b5" name="aa414fce4f0f3a013dc158166918982b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa414fce4f0f3a013dc158166918982b5">&#9670;&#160;</a></span>issue_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a> legate::Runtime::issue_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a> &gt;&#160;</td>
          <td class="paramname"><em>redop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues a copy between stores. </p>
<p>The source and target stores must have the same shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Copy target </td></tr>
    <tr><td class="paramname">source</td><td>Copy source </td></tr>
    <tr><td class="paramname">redop</td><td>ID of the reduction operator to use (optional). The store's type must support the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the store's type doesn't support the reduction operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac39cd813542d5c291a4db065ba836e13" name="ac39cd813542d5c291a4db065ba836e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39cd813542d5c291a4db065ba836e13">&#9670;&#160;</a></span>issue_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a> legate::Runtime::issue_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="group__types.html#gaf066ee3ee59b3247104e036a26e52525">ReductionOpKind</a> &gt;&#160;</td>
          <td class="paramname"><em>redop</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues a copy between stores. </p>
<p>The source and target stores must have the same shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Copy target </td></tr>
    <tr><td class="paramname">source</td><td>Copy source </td></tr>
    <tr><td class="paramname">redop</td><td>ID of the reduction operator to use (optional). The store's type must support the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the store's type doesn't support the reduction operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee58f31c99882ddd268c3f52e4ee3055" name="aee58f31c99882ddd268c3f52e4ee3055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee58f31c99882ddd268c3f52e4ee3055">&#9670;&#160;</a></span>issue_execution_fence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a> legate::Runtime::issue_execution_fence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">bool</a>&#160;</td>
          <td class="paramname"><em>block</em> = <code><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">false</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues an execution fence. </p>
<p>An execution fence is a join point in the task graph. All operations prior to a fence must finish before any of the subsequent operations start.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>When <code>true</code>, the control code blocks on the fence and all operations that have been submitted prior to this fence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a833ad58d72b2f63d97d611e64d61707b" name="a833ad58d72b2f63d97d611e64d61707b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833ad58d72b2f63d97d611e64d61707b">&#9670;&#160;</a></span>issue_fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a> legate::Runtime::issue_fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a given array with a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Logical array to fill </td></tr>
    <tr><td class="paramname">value</td><td>Logical store that contains the constant value to fill the array with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf6c33cbccba7c9eee327166c99d8fb6" name="abf6c33cbccba7c9eee327166c99d8fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6c33cbccba7c9eee327166c99d8fb6">&#9670;&#160;</a></span>issue_fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a> legate::Runtime::issue_fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalArray.html">LogicalArray</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1Scalar.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a given array with a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Logical array to fill </td></tr>
    <tr><td class="paramname">value</td><td>Value to fill the array with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14f4fd6bb0629d8c68d1b61f91f12405" name="a14f4fd6bb0629d8c68d1b61f91f12405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f4fd6bb0629d8c68d1b61f91f12405">&#9670;&#160;</a></span>issue_gather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a> legate::Runtime::issue_gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>source_indirect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a> &gt;&#160;</td>
          <td class="paramname"><em>redop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues a gather copy between stores. </p>
<p>The indirection store and the target store must have the same shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Copy target </td></tr>
    <tr><td class="paramname">source</td><td>Copy source </td></tr>
    <tr><td class="paramname">source_indirect</td><td>Store for source indirection </td></tr>
    <tr><td class="paramname">redop</td><td>ID of the reduction operator to use (optional). The store's type must support the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the store's type doesn't support the reduction operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68c37be0dcdd6d0423839f16024541f7" name="a68c37be0dcdd6d0423839f16024541f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c37be0dcdd6d0423839f16024541f7">&#9670;&#160;</a></span>issue_gather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a> legate::Runtime::issue_gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>source_indirect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="group__types.html#gaf066ee3ee59b3247104e036a26e52525">ReductionOpKind</a> &gt;&#160;</td>
          <td class="paramname"><em>redop</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues a gather copy between stores. </p>
<p>The indirection store and the target store must have the same shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Copy target </td></tr>
    <tr><td class="paramname">source</td><td>Copy source </td></tr>
    <tr><td class="paramname">source_indirect</td><td>Store for source indirection </td></tr>
    <tr><td class="paramname">redop</td><td>ID of the reduction operator to use (optional). The store's type must support the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the store's type doesn't support the reduction operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22d5f2fb683c13c9583584b1cacc285e" name="a22d5f2fb683c13c9583584b1cacc285e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d5f2fb683c13c9583584b1cacc285e">&#9670;&#160;</a></span>issue_scatter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a> legate::Runtime::issue_scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>target_indirect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a> &gt;&#160;</td>
          <td class="paramname"><em>redop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues a scatter copy between stores. </p>
<p>The indirection store and the source store must have the same shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Copy target </td></tr>
    <tr><td class="paramname">target_indirect</td><td>Store for target indirection </td></tr>
    <tr><td class="paramname">source</td><td>Copy source </td></tr>
    <tr><td class="paramname">redop</td><td>ID of the reduction operator to use (optional). The store's type must support the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the store's type doesn't support the reduction operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad738289cb4ab668259453be1e3337c2f" name="ad738289cb4ab668259453be1e3337c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad738289cb4ab668259453be1e3337c2f">&#9670;&#160;</a></span>issue_scatter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a> legate::Runtime::issue_scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>target_indirect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="group__types.html#gaf066ee3ee59b3247104e036a26e52525">ReductionOpKind</a> &gt;&#160;</td>
          <td class="paramname"><em>redop</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues a scatter copy between stores. </p>
<p>The indirection store and the source store must have the same shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Copy target </td></tr>
    <tr><td class="paramname">target_indirect</td><td>Store for target indirection </td></tr>
    <tr><td class="paramname">source</td><td>Copy source </td></tr>
    <tr><td class="paramname">redop</td><td>ID of the reduction operator to use (optional). The store's type must support the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the store's type doesn't support the reduction operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4485bb806540bdf82cb280e8f3925def" name="a4485bb806540bdf82cb280e8f3925def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4485bb806540bdf82cb280e8f3925def">&#9670;&#160;</a></span>issue_scatter_gather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a> legate::Runtime::issue_scatter_gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>target_indirect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>source_indirect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a> &gt;&#160;</td>
          <td class="paramname"><em>redop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues a scatter-gather copy between stores. </p>
<p>The indirection stores must have the same shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Copy target </td></tr>
    <tr><td class="paramname">target_indirect</td><td>Store for target indirection </td></tr>
    <tr><td class="paramname">source</td><td>Copy source </td></tr>
    <tr><td class="paramname">source_indirect</td><td>Store for source indirection </td></tr>
    <tr><td class="paramname">redop</td><td>ID of the reduction operator to use (optional). The store's type must support the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the store's type doesn't support the reduction operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64512438655e1df2317760ad0f362710" name="a64512438655e1df2317760ad0f362710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64512438655e1df2317760ad0f362710">&#9670;&#160;</a></span>issue_scatter_gather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a> legate::Runtime::issue_scatter_gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>target_indirect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>source_indirect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="group__types.html#gaf066ee3ee59b3247104e036a26e52525">ReductionOpKind</a> &gt;&#160;</td>
          <td class="paramname"><em>redop</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues a scatter-gather copy between stores. </p>
<p>The indirection stores must have the same shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Copy target </td></tr>
    <tr><td class="paramname">target_indirect</td><td>Store for target indirection </td></tr>
    <tr><td class="paramname">source</td><td>Copy source </td></tr>
    <tr><td class="paramname">source_indirect</td><td>Store for source indirection </td></tr>
    <tr><td class="paramname">redop</td><td>ID of the reduction operator to use (optional). The store's type must support the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the store's type doesn't support the reduction operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69f1b1a0680f90f4a0ca579a7b95d65a" name="a69f1b1a0680f90f4a0ca579a7b95d65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f1b1a0680f90f4a0ca579a7b95d65a">&#9670;&#160;</a></span>maybe_find_library()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classlegate_1_1Library.html">Library</a> &gt; legate::Runtime::maybe_find_library </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>library_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to find a library. </p>
<p>If no library exists for a given name, a null value will be returned</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">library_name</td><td><a class="el" href="classlegate_1_1Library.html" title="A library class that provides APIs for registering components.">Library</a> name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlegate_1_1Library.html" title="A library class that provides APIs for registering components.">Library</a> object if a library exists for a given name, a null object otherwise </dd></dl>

</div>
</div>
<a id="aeb9a69f276edfdef8c2221cacb4c811c" name="aeb9a69f276edfdef8c2221cacb4c811c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9a69f276edfdef8c2221cacb4c811c">&#9670;&#160;</a></span>submit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a> legate::Runtime::submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlegate_1_1AutoTask.html">AutoTask</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits an <a class="el" href="classlegate_1_1AutoTask.html" title="A class for auto-parallelized task desciptors.">AutoTask</a> for execution. </p>
<p>Each submitted operation goes through multiple pipeline steps to eventually get scheduled for execution. It's not guaranteed that the submitted operation starts executing immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>An <a class="el" href="classlegate_1_1AutoTask.html" title="A class for auto-parallelized task desciptors.">AutoTask</a> to execute </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5f15f26d31e9400f1e6e5feef0c697d" name="ad5f15f26d31e9400f1e6e5feef0c697d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f15f26d31e9400f1e6e5feef0c697d">&#9670;&#160;</a></span>submit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">void</a> legate::Runtime::submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlegate_1_1ManualTask.html">ManualTask</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a <a class="el" href="classlegate_1_1ManualTask.html" title="A class for manually parallelized task descriptors.">ManualTask</a> for execution. </p>
<p>Each submitted operation goes through multiple pipeline steps to eventually get scheduled for execution. It's not guaranteed that the submitted operation starts executing immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>A <a class="el" href="classlegate_1_1ManualTask.html" title="A class for manually parallelized task descriptors.">ManualTask</a> to execute </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab96e6b441e6c225a9a7508f1f91c8122" name="ab96e6b441e6c225a9a7508f1f91c8122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96e6b441e6c225a9a7508f1f91c8122">&#9670;&#160;</a></span>tree_reduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> legate::Runtime::tree_reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlegate_1_1Library.html">Library</a>&#160;</td>
          <td class="paramname"><em>library</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int64_t</a>&#160;</td>
          <td class="paramname"><em>task_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">const</a> <a class="el" href="classlegate_1_1LogicalStore.html">LogicalStore</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__data.html#ga655d14b01317cd85edf3433f410fda0d">int32_t</a>&#160;</td>
          <td class="paramname"><em>radix</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs reduction on a given store via a task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">library</td><td>The library for the reducer task </td></tr>
    <tr><td class="paramname">task_id</td><td>reduction task ID </td></tr>
    <tr><td class="paramname">store</td><td>Logical store to reduce </td></tr>
    <tr><td class="paramname">radix</td><td>Optional radix value that determines the maximum number of input stores to the task at each reduction step </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="runtime_8h_source.html">runtime.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
